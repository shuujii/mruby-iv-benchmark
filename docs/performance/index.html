<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8"><title>Instance Variable Table Benchmark for mruby</title><link rel="stylesheet" href="/mruby-iv-benchmark/css/main.css"><link rel="stylesheet" href="/mruby-iv-benchmark/css/uPlot.min.css"><script src="/mruby-iv-benchmark/js/uPlot.iife.min.js"></script><script src="/mruby-iv-benchmark/js/chart.js"></script></head><body><header><h1><a href="/mruby-iv-benchmark/">Instance Variable Table Benchmark for mruby</a></h1><div><a href="https://github.com/shuujii/mruby-iv-benchmark">GitHub</a></div></header><nav id="toc"><ul><li><a href="/mruby-iv-benchmark/" class="h2">Introduction</a></li><li><a href="/mruby-iv-benchmark/environment" class="h2">Environment</a><ul><li><a href="/mruby-iv-benchmark/environment#benchmark-code" class="h3">Benchmark Code</a></li><li><a href="/mruby-iv-benchmark/environment#implementation" class="h3">Implementation</a></li><li><a href="/mruby-iv-benchmark/environment#platform" class="h3">Platform</a><ul><li><a href="/mruby-iv-benchmark/environment#os" class="h4">OS</a></li><li><a href="/mruby-iv-benchmark/environment#hardware" class="h4">Hardware</a></li></ul></li><li><a href="/mruby-iv-benchmark/environment#compiler" class="h3">Compiler</a></li><li><a href="/mruby-iv-benchmark/environment#type-size" class="h3">Type Size</a></li></ul></li><li><a href="/mruby-iv-benchmark/memory-usage" class="h2">Memory Usage</a></li><li class="active"><a href="#performance" class="h2">Performance</a><ul><li><a href="#mrb_obj_iv_set" class="h3"><code>mrb_obj_iv_set</code></a></li><li><a href="#mrb_obj_iv_get" class="h3"><code>mrb_obj_iv_get</code></a></li></ul></li><li><a href="/mruby-iv-benchmark/binary-size" class="h2">Binary Size</a></li></ul></nav><article id="content">
<h2 id="performance">Performance</h2>

<h3 id="mrb_obj_iv_set"><code>mrb_obj_iv_set</code></h3>

<p>空の <code>iv_tbl</code> に <em>N</em> 個のエントリーを <code>mrb_obj_iv_set</code> で挿入した際の、1回あたりの時間 (上図) と総時間 (下図) の計測結果です。</p>
<div id="chart-performance-c-set" class="line-chart"><div class="modes"><div data-mode="64-word" class="mode">64-bit Word-boxing</div><div data-mode="64-nan" class="mode">64-bit NaN-boxing</div><div data-mode="64-no" class="mode">64-bit No-boxing</div><div data-mode="32-word" class="mode">32-bit Word-boxing</div><div data-mode="32-no" class="mode">32-bit No-boxing</div></div><div class="chart-item"><div class="chart"></div><div class="legend"><div class="legend-header">iv_tbl size: --</div><div class="legend-body"><div class="legend-items"><div class="legend-item v2_1_2"><div class="legend-figure"></div><div class="legend-label">2.1.2:</div><div class="legend-value">--</div><div class="legend-unit">M i/s</div></div><div class="legend-item baseline"><div class="legend-figure"></div><div class="legend-label">Baseline:</div><div class="legend-value">--</div><div class="legend-unit">M i/s</div></div><div class="legend-item new"><div class="legend-figure"></div><div class="legend-label">New:</div><div class="legend-value">--</div><div class="legend-unit">M i/s</div></div></div><div class="legend-notes"><div>Drag and drop to zoom in (double-click resets)</div></div></div></div></div><div class="chart-item"><div class="chart"></div><div class="legend"><div class="legend-header">iv_tbl size: --</div><div class="legend-body"><div class="legend-items"><div class="legend-item v2_1_2"><div class="legend-figure"></div><div class="legend-label">2.1.2:</div><div class="legend-value">--</div><div class="legend-unit">M i/s</div></div><div class="legend-item baseline"><div class="legend-figure"></div><div class="legend-label">Baseline:</div><div class="legend-value">--</div><div class="legend-unit">M i/s</div></div><div class="legend-item new"><div class="legend-figure"></div><div class="legend-label">New:</div><div class="legend-value">--</div><div class="legend-unit">M i/s</div></div></div><div class="legend-notes"><div>Drag and drop to zoom in (double-click resets)</div></div></div></div></div></div>
<p>64-bit CPU では1回あたりの時間は両実装とも概ね同等ですが、ハッシュバケットの拡大時は New 実装がやや速いため総時間は New 実装がやや速くなっています。ハッシュバケットの拡大時の性能向上はおそらくデータ構造の変更の影響よりもいくらか無駄な処理を改善したことの影響が大きいかもしれません。</p>

<p>32-bit CPU でも概ね同じ傾向ですが 64-bit CPU と比較すると New 実装がやや遅いようです。64-bit CPU では構造体のパディングが削除されたこととハッシュテーブルのキーが連続したことにより参照局所性が高くなったことが有利に働いているのではないかと考えています。</p>

<h3 id="mrb_obj_iv_get"><code>mrb_obj_iv_get</code></h3>

<p>サイズが <em>N</em> の <code>iv_tbl</code> に対してすべてのキーと1個の存在しないキーを <code>mrb_obj_iv_get</code> で参照した際の、1回あたりの平均時間の計測結果です。</p>
<div id="chart-performance-c-get" class="line-chart"><div class="modes"><div data-mode="64-word" class="mode">64-bit Word-boxing</div><div data-mode="64-nan" class="mode">64-bit NaN-boxing</div><div data-mode="64-no" class="mode">64-bit No-boxing</div><div data-mode="32-word" class="mode">32-bit Word-boxing</div><div data-mode="32-no" class="mode">32-bit No-boxing</div></div><div class="chart-item"><div class="chart"></div><div class="legend"><div class="legend-header">iv_tbl size: --</div><div class="legend-body"><div class="legend-items"><div class="legend-item v2_1_2"><div class="legend-figure"></div><div class="legend-label">2.1.2:</div><div class="legend-value">--</div><div class="legend-unit">M i/s</div></div><div class="legend-item baseline"><div class="legend-figure"></div><div class="legend-label">Baseline:</div><div class="legend-value">--</div><div class="legend-unit">M i/s</div></div><div class="legend-item new"><div class="legend-figure"></div><div class="legend-label">New:</div><div class="legend-value">--</div><div class="legend-unit">M i/s</div></div></div><div class="legend-notes"><div>Drag and drop to zoom in (double-click resets)</div></div></div></div></div></div>
<p>New 実装 は 64-bit CPU では若干速いようですが、32-bit CPU では逆にやや遅くなっています。64-bit CPU で速くなっているのは参照局所性が高くなったことが原因ではないかと考えています。32-bit CPU では元々構造体のパディングがなかったためその恩恵があまりなく、逆に何らかのオーバーヘッドのコストが高くなっているのではないかと考えていますが、具体的な原因は分かっていません。</p>
</article></body></html>
